program bccKpointsIntegration
  !*
  !* This program generates the (kx,ky,kz) grid in asending order
  !* for a BCC-IBZ using kmin < kc < kmax and calculates
  !* the area of the sphere of radius kc
  !*
  !* script: fs-bz-bcc-grid-integrate.sh
  !*
  !* input files
  !*
  !* fort.1(=out)=$sym/$case.kband_$band\_$Nk OK
  !* fort.123 OK
  !* fort.244 & fort.245 OK
  !*
  !* output files
  !* fort.12 => ideal FS OK
  !* fort.71 => Ideal FS @ $sym/$case.ideala-ibz\_$knia OK
  !* fort.200 => grad=-1 & BF=0 for FS
  !* fort.201 => grad=-1 & BF=1 for FS
  !* fort.202 => grad=+1 & BF=0 for FS
  !* fort.203 => grad=+1 & BF=1 for FS
  !* fort.8 => kcBand37 OK
  !* fort.246 => FS $case.kflist_$ene with cartesian k-points & data for integration OK
  !* fort.35 => area-vs-k-fs.dat OK
  !*
  !* OLD-output files
  !*
  !* fort.(69,70)   => weight=48   (Ideal,FS)
  !* fort.(71,72)   => all weights (Ideal,FS)
  !* fort.(500,501) => weight=48   Ideal (in->out,out->in)
  !* fort.(502,503) => weight=48   FS    (in->out,out->in)
  !* fort.(400,401) => all weights Ideal (in->out    ,    out->in)
  !*                                 (1,2,3)->(4,5,6) (1,2,3)->(4,5,6)
  !* => Ideal Spherical Fermi Surface k-points are given by
  !* => fort.401@(4,5,6)-all-in  k-points @ideal-bz-bcc-grid-integrate.sh:  kin=$sym/$case.ideala.in
  !* => fort.400@(4,5,6)-all-out k-points @ideal-bz-bcc-grid-integrate.sh: kout=$sym/$case.ideala.out
  !*
  !* fort.(402,403) => all weights FS (in->out,out->in)
  !*
  !* fort.(201,200) => all weights FS (in,out) we chose fort.201 "in" as the Fermi-surface
  !* fort.201       => all weights FS where $10=1 => grad=+1 kpoints or $10=-1 => grad=-1 kpoints
  !* fort.(202,203) => all weights FS (in-out,out->in) vectors for grad=-1
  !* fort.(204,205) => all weights FS (in-out,out->in) vectors for grad=+1
  !*
  !*  fort.12 => all kmin < k < kmax
  !*  fort.29 = (fort.12 = fort.30 = fort.3 = fort.4 not printed)
  !*  fort.803, fort.22 => not printed
  !*  fort.69=fort.70 => weight=48 or inner points
  !*  fort.71 => has GPH points missing
  !*  fort.4 = fort.12 => all kmin < k < kmax
  !*  fort.899 not needed
  !*  fort.61 => gradf(x,y,z)= -1 or 0 & w=48 & w=24 only @ GNP-plane
  !*  fort.60 => gradf(x,y,z)= -1  & w=48 & w=24 only @ GNP-plane
  use mpi 
  IMPLICIT NONE
  !REAL(8), ALLOCATABLE, DIMENSION(:) :: kvecin,kvecout
  type ragged_array
     real(8),allocatable :: kvin(:),kvout(:),kvinf(:),kvoutf(:)
     real(8),allocatable :: kvina(:),kvouta(:),kvinfa(:),kvinfap(:),kvoutfa(:),kvoutfap(:)
  end type ragged_array
  type(ragged_array),allocatable:: ikvin(:) ,ikvout(:) ,ikvinf(:) ,ikvoutf(:)
  type(ragged_array),allocatable:: ikvina(:),ikvouta(:),ikvinfa(:),ikvinfap(:),ikvoutfa(:),ikvoutfap(:)
  REAL(8), ALLOCATABLE :: d(:)
  !
  REAL(8), ALLOCATABLE :: energy(:)
  REAL(8), ALLOCATABLE :: rx(:),ry(:),rz(:)
  REAL(8), ALLOCATABLE :: rxx(:),ryy(:),rzz(:)
  REAL(8), ALLOCATABLE :: B(:,:,:),BF(:,:,:)
  REAL(8), ALLOCATABLE :: weight(:,:,:)
  INTEGER, ALLOCATABLE :: tagi(:,:,:)
  REAL(8), ALLOCATABLE :: kpi(:),kpo(:)
  REAL(8), ALLOCATABLE :: rxm(:),rym(:),rzm(:)
  REAL(8), ALLOCATABLE :: rxp(:),ryp(:),rzp(:)
  INTEGER :: N,i,j,k,w,tag
  INTEGER :: Nk,aNk
  INTEGER :: numm,nump,dummy
  INTEGER :: conta,contall,contaf,contafa
  INTEGER :: ini,nf,inia,nfa
  INTEGER :: contin,contout,maxvec,mini
  INTEGER :: contina,contouta
  INTEGER :: continf,contoutf,continfa,contoutfa
  INTEGER :: contap,contam,nm,np,l,m,which
  REAL(8) :: min,gtest
  REAL(8) :: pi,a,g
  REAL(8) :: maxX,maxY,maxZ
  REAL(8) :: km,kc,p
  REAL(8) :: kcBand,band
  REAL(8) :: kmin,kmax
  REAL(8) :: dumy,dx,dy,dz,circun,circuna,circunf,circunfa
  REAL(8) :: gradx,grady,gradz,grad
  REAL(8) :: gradxf,gradyf,gradzf,gradf
  REAL(8) :: g2x,g2y,g2z
  REAL(8) :: g2xf,g2yf,g2zf
  REAL(8) :: aexact,error,errorall
  REAL(8) :: efermi,x,y,z,BB
  REAL(8) :: dum,peso,am,ap
  REAL(8) :: xx,yy,zz,wei,Be
  REAL(8) :: vec,tol
!  REAL(8) :: zm,xm,ym1,ym2
!  REAL(8) :: xp,yp1,yp2,zp
  REAL(8) :: yminp,ymaxp
! REAL(8) :: xminm,xmaxm,yminm,ymaxm,zminm,zmaxm
!  REAL(8) :: z1,z2
!  REAL(8) :: kxyz
  !!                                                      w=48
  !!         wxyz: w=(c->counter,a->area), x=(a->all k,i->inner k), y=(i->below E_F,o->above E_F), z=(m->grad=-1,p->grad=+1)
  REAL(8) :: caom,aaom,caim,aaim
  REAL(8) :: caop,aaop,caip,aaip
  INTEGER, ALLOCATABLE :: ind(:),jnd(:),knd(:),yes(:,:,:)
  INTEGER, ALLOCATABLE :: ii(:),jj(:),kk(:)
  integer :: ierr, rank, nprocs
  pi=acos(-1.)
  nm=2105
  76 format(3f13.8,1i5,2f4.0,3i6,3e13.5)
  !reads data
  !        1 2  3 4  5 6      7      8    9  10 11  12
  !write(*,*)'stopping @bands-fs-bz-bcc-grid-integrate.f90'
  !stop
  !
  !reads data-----Down
  !From the coarse-grained first FS data generated by
  !fs-bz-bcc-grid-integrate.sh
  !and stored @
  !  symmetries/y2c3.fs-ibz-in-cg-?-r-?-k-?-1-? @ Grad=-1  -> fort.244
  !  symmetries/y2c3.fs-ibz-in-cg-?-r-?-k-?+1-? @ Grad=+1  -> fort.245
  !Â¿
  !A denser grid of k-points will be calculated
  !JUST around above coarse-grained FS-k-points.
  !
  !Then, we must run_tiniba.sh with these points,
  !to generate E(k) from which a refined FS would be obtained.
  !
  ! valid for all bands
  open(244,file='fort.244-Ncg-151-N-201')
  allocate(rxm(nm),rym(nm),rzm(nm))
  allocate(rxp(nm),ryp(nm),rzp(nm))
  do l=1,nm
     !fort.244 -> symmetries/y2c3.fs-ibz-in-?-1-N1 (57) @ Grad=-1
     read(244,*)rxm(l),rym(l),rzm(l),dumy,dumy,dx,dy,dz
  end do
  !write(*,*) "aqui voy"
  !stop
  close(244)
  write(*,*)'fort.244 with',nm,'was read'
  ! only bands 36 and 37 have two FS
  if ( (band .eq. 36) .or. (band .eq. 37) ) then
     do l=1,np
        !fort.245 -> symmetries/y2c3.fs-ibz-in-?+1-N1 (59) @ Grad=+1
        read(245,*)rxp(l),ryp(l),rzp(l),dumy,dumy,dx,dy,dz
     end do
     close(245)
     write(*,*)'fort.245 with',np,'was read'
  end if 
  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  !Read fort.21 (grad=+1) and fort.22 (grad=-1) to calculate the vector
  write(*,*)'        *****'
  write(*,*)'        @bands-fs-bz-bcc-grid-integrate.f90'
  write(*,*)N,'divisions =>',contap,'k-p grad=+1 @CorseGFS',np
  write(*,*)'                      and',contam,'k-p grad=-1 @CorseGFS',nm
  !write(*,*)'stopping @bands-fs-bz-bcc-grid-integrate.f90'
  !stop
  !
  !grad=-1-DOWN
  !valid for all bands
  !
  !New tol value:
  !we use
  !radius=sqrt(dx^2 + dy^2 + dz^2)
  !which gives the radius along the
  !diagonal of a boxel of the Cartesian BCC grid.
  !We take
  !tol=radius
  !which would be equivalent to an small number of boxels around
  !the (xx,yy,zz)-kpoint of the CG-grid. As we increase the refinement of
  !the grid, tol=r would be smaller than the original fixed value of .0075 that
  !works just fine, but has the disadvantage that as we increase the refinement
  !it would include k-points that would be farther away from the CG-FS, thus
  !wasting computational precious time!
  allocate(rx(inia:nfa),ry(inia:nfa),rz(inia:nfa))
  dx=abs(rx(1)-rx(2))
  dy=abs(ry(1)-ry(2))
  dz=abs(rz(1)-rz(2))
  !Comment bellow if you want to externally read the value of tol
  tol=tol*sqrt(dx**2 + dy**2 + dz**2)
  !
  !write(321,*)tol,sqrt(dx**2 + dy**2 + dz**2)
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!! Takes the previous CG as a seed for the next grid                         !!!!!
  !!!! Each k-point of the next grid is within tol-distance of the previous grid !!!!!
  !!!! @@@@@@@@@@@@PARALELIZE@@@@@@@@@@@
  !the rxm,rym,rzm are read from fort.244
  !read(244,*)rxm(l),rym(l),rzm(l),dumy,dumy,dx,dy,dz

  call MPI_Init(ierr)
  call MPI_COMM_SIZE(MPI_COMM_WORLD,nprocs,ierr) 
  call MPI_Comm_RANK(MPI_COMM_WORLD,rank,ierr)

  do l=1,contam
     !reads CG grid
     read(21,*)xx,yy,zz,tag,wei,Be,i,j,k
     do m=1,nm
        vec=sqrt( (xx-rxm(m))**2 + (yy-rym(m))**2 + (zz-rzm(m))**2 )
        write(851,*)l,m,vec
        if ( vec .le. tol ) then
           rx(i)=xx
           ry(j)=yy
           rz(k)=zz
           weight(i,j,k)=wei
           B(i,j,k)=Be
           !fort.751 => grad=-1 new k-points around FS@pocket
           write(751,76)rx(i),ry(j),rz(k),tag,weight(i,j,k),B(i,j,k),i,j,k,dx,dy,dz
        end if
     end do
   end do

  call MPI_Finalize(ierr)


  write(*,*) "aqui voy"
  stop
  END
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !!!
